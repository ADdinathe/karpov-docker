# За пределами контейнеров
## Ansible
Итак, наши программы должны оказаться на продовом сервере. Какой путь?
- Мы зворачиваем в коробку (docker build)
- Отправляем на сервер
- Разворачиваем на сервере (docker run)

А что с отправкой на сервер?
- Скопировать вручную на сервер (scp, rsync) - сгодится только для pet-проектов или приложений, работающих в армках одного сервера. В современном мире такой способ доставки не используется. Но и тут странно получается, мы переносим все файлы на сервер, собираем ее там и запускаем (равносильно тому, что почтальен принесет нам посылку и при нас же ее упакует перед вручением)
- Докер-репозиторий: собрали программу в образ, запушили в репозиторий, оттуда стянули образ на сервер и запустили. Здесь мы решили проблему с прекращением сборки на сервере, но не решили проблему нескольких серверов.
- Ansible - SCM (system configuration management) - приложение для удаленного управления конфигурациями. Что-то делаем на сервере не заходя в него. Конфигурация описывается в YAML формате. Условно получается так, мы локально собрали образ, запушили его. А затем запускаем ansible, который идет по серверам и поднимает контейнеры с приложениями.

Посмотрим пример см. папку ansible:

Важно обратить внимание на то, что nginx.conf лежит рядом с Dockerfile. С ними мы уже знакомы, но кроме них здесь есть файлы inventory и palybook.yaml.

Задача сейчас - попасть на удаленный сервер, только делаем это локально (сами не переходим на сервер, ansible сам пойдет на сервер).

Собираем образ, но называем его так, как он будет называться на docker.hub:
```bash
docker build -t kcoursedocker/frontend-demo:v1 .
```

Теперь отправим его на docker.hub:
```bash
# Логинимся в docker.hub локально, вводим логин и пароль после этой команды
docker login

# Запушим
docker push kcoursedocker/frontend-demo:v1
```

А как теперь это отправить на сервер? Переходим к ansible. Для ansible в самом простом случае, мы заводим 2 файлика: inventory и playbook.yaml:
- **invetory** - это место, где мы описываем наши сервера (на какие сервера надо сходить) (в файле [production] - это секция, а ниже доме/ip или несколько серверов, также может быть несколько секций).
- **playbook.yaml** - файл, где мы описываем задачи. Здесь мы отпарвялем файлик на сервер и поднимаем контейнер. Структура простая, в реальных проектах сложнее, но принцип соверешнно такой же.

Запускаем ansible:
```bash
asnible-playbook -i inventory playbook.yaml
```

Если еще раз запустить эту команду, то ansible сначала посмотрит на сервер и увидит, что там все есть и не будет скачивать. Если удалить nginx.conf на сервере и запустить ansible, то он только восстановит этот файл.

Еще одна фишка ansible - позволяет хранить секретные данные: файл **credentials.yaml**
```bash
ansible-vault encrypt credentials.yaml
# Вводим какой-нибудь пароль
```
Теперь наш конфиг с токенами закодировался, теперь такое можно выложить и на гитхаб.
Можно посмотреть раскодированные токены командой view:
```bash
ansible-vault view credentials.yaml
# Вводим указанный ранее пароль
```
Или раскодировать:
```bash
ansible-vault decrypt credentials.yaml
# Вводим указанный ранее пароль
```

## CICD continuous integration & continuous deployment
Комбинация непрерывной интеграции и развертывания. Представим: процесс разработки, тестирования, сборки и деплоя приложения отвечаем мы сами - делаем вручную. А теперь сделаем так, что руками ведем только процесс разработки, а все остальное автоматизированно. У нас будет некоторое место, где будет находится наш код, допустим github, в нем у нас будем самая главная ветка - master (продовый код). Разработчики берут код из мастера и кладут в свою ветку, а когда они поработали эту ветку они пушат на гитхаб (влив ее в мастер). А как этот код доставить до прода? 

На примере простого приложения попробуем его задеплоить вот таким образом. Для этого вспользуемся gitlab CICD. Также существуют и другие Github Actions, Jenkins и другие.

Создаем репозиторий на гитлабе. Переходим в Settings - General - Repository. Ищем Merge requests - Merge commit и Protected branches.
- Protected branches - указываем, что никто не может пушить код в эту ветку (master). А как туда попадут изменения? - Через merge.
- Merge requests - как файлы будут попадать в мастер: Piplines must succeed - запуск проверок при вливании в мастер.


